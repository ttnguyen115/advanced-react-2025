# 1. SSR and CSR

## 1.1. SSR (Server side rendering)

- Render HTML from backend.
- Browser fetches HTML and display it.
- JS bundle -> hydrate -> interactivity.
- Disadvantages:
  - Server handles a lot of rendering -> consume CPU, hard to scale.
  - Wait for JS bundle interact with browser.
  - Consume bandwidth.

## 1.2. CSR (Client side rendering)

- Server returns empty HTML skeleton + JS bundle.
- Browser fetches JS bundle -> render UI on client.

|                  | SSR                                | CSR                                     |
| :--------------- | :--------------------------------- | :-------------------------------------- |
| **SEO**          | True                               | False (because need JS bundle)          |
| **TFP**          | Fast                               | Slow (because JS bundle + calling APIs) |
| **UX**           | Hydration delay                    | After loading                           |
| **Suitable for** | Blog, e-commerce, landing page,... | Dashboard, SaaS app, SPA                |

## 1.3. SEO (Search Engine Optimization)

- Sematic HTML: `<title> <h1> <h2> <header> ...`
- Performance & Core Web Vitals.
- Mobile & Responsive (Mobile-first design).

```html
<meta name="**viewport**" content="width=device-width, initial-scale=1.0" />
```

# 2. SPA and MPA

## 2.1 Single Page Application (SPA)

- Downloads HTML file along with bundled JavaScript and CSS
- Handles routing within the browser, updating the page via JavaScript without full reloads
- Typically requests data via API (REST/GraphQL)
- Examples: Trello, Notion, Gmail

## 2.2 Multi-Page Application (MPA)

- Each URL corresponds to an HTML page, rendered by the server and sent to the client
- Routing involves loading a full new page
- Data is delivered through traditional Server-Side Rendering (SSR) or directly within the HTML
- Examples: Online newspapers, blogs, landing pages

## 2.3 SPA vs MPA Comparison

| Feature                  | SPA (Single Page Application)                                      | MPA (Multi Pages Application)                                                        |
| :----------------------- | :----------------------------------------------------------------- | :----------------------------------------------------------------------------------- |
| **Render**               | CSR (Client-Side Rendering) + SSR/hydration (depends on framework) | SSR (Server-Side Rendering)                                                          |
| **Routing**              | No reload, smooth                                                  | Reload, can cause blank page                                                         |
| **First load**           | JS bundle -> heavy, slow Time to Interactive (TTI)                 | HTML includes data -> First Contentful Paint (FCP) good                              |
| **SEO**                  | Not good                                                           | Good                                                                                 |
| **Security**             | JWT/OAuth                                                          | Cookie-session                                                                       |
| **Performance Analysis** | Rely on bundle, code-split, prefetch                               | Rely on **TTFB/FCP** (Time to First Byte / First Contentful Paint) each page + cache |

# 3. React

## 3.1. React project structure with Vite

- **Vite**: next generation frontend build tool.
  - Runs **dev server** with **hot reload**.
    - Take advantages of native ES Modules (ESM).
    - Re-compiles just changed file and pushes the update to the browser via WebSocket.
  - Transforms JSX/TSX to plain JavaScript.
  - Bundles and optimizes code no Vite, manually configure **Babel, Webpack/Rollup**.

## 3.2. Class component

### *this* in class component

- In methods, *this* will be **null** by default.
- *bind* this in constructor -> reference *this*. 

```jsx
class Example extends React.Component<any, any> {
  constructor(props: any) {
    super(props);
    this.state = {
      value: '111',
    };
    this.handleClick3 = this.handleClick3.bind(this);
  }
  componentDidMount(): void { console.log('this ', this); } // console: 'this' points to this component
  handleClick1() { console.log('Click 1'); } // console: Click 1
  handleClick2() { console.log('this ', this); } // console: undefined
  handleClick3() { this.setState({ value: 'Click 3' }); } // UI: Value Click 3
  handleClick4(value: string) { this.setState({ value }); } // UI: Value Click 4
  render() {
    return (
      <>
        <button onClick={this.handleClick1}>Click 1</button>
        <button onClick={this.handleClick2}>Click 2</button>
        <button onClick={this.handleClick3}>Click 3</button>
        <button onClick={() => this.handleClick4('Click 4')}>Click 4</button>
        <p>Value {this.state?.value}</p>
      </>
    )
  }
}
```

## 3.3. React reconciliation

- Reconciliation is the algorithm React uses to decide how to update the UI when components'state or props change.
- Goal: Minimize costly DOM operations by reusing as much of the existing UI as possible.

### Why needs React reconciliation

- The DOM is slow to update, so React wants to:
  - Avoid re-rendering unchanged parts.
  - Update only what's necessary.
- Before React 16:
  - React uses stack reconciler.
  - If big -> slow render - UI can be lagged (cannot interrupt).

## 3.4. React fiber

- Fiber is a data structure (implemented as a linked list tree) that represents each node in the **React tree**
- Fiber turns the rendering process into something "**pausable** and **resumable**", making React more efficient and responsive.
  - Breaks rendering into chunks (units of work) -> React can pause, abort, and restart rendering.
  - Supports features like Concurrent Rendering, Suspense, and transitions.

### How Fiber works?

- Render phase (Reconciliation):
  - Builds a new Fiber tree based on the new Virtual DOM.
  - Compares it with the old Fiber tree.
  - Records the "effects" that need to be applied (e.g., DOM updates).
  - can be **paused**, **aborted**, or **restarted**.
- Commit phase:
  - Applies the collected effects synchronously to the actual DOM.
  - The Commit phase cannot be interrupted.

## 3.5. Virtual DOM

- A virtual DOM object is the same as a real DOM object, lightweight copy.
- Cannot manipulate on-screen elements.
- Changes -> only updates the corresponding nodes and not the entire tree.
- **Heuristics** are rules:
  - Avoid comparing entire trees recursively.
  - Same type -> **keeps the existing DOM node**, only updates its attributes/props.
  - **Different type** of element -> destroys the old node and everything under it, create new one.
  - List of elements -> use **key** to track identity.
  
### How Virtual DOM works?

- Render a new Virtual DOM.
- Compare new Virtual DOM snapshot with old Virtual DOM snapshot (diffing).
- Find out minimum changes.
- Only update that parts on real DOM.



## 3.6. Suspense + Concurrent Rendering

- Handle asynchronous boundaries
- Pause ("suspend") rendering until data or code is ready, then show a fallback UI in the meantime.
- Provides the **loading boundary**, while **transitions/deferred** values handle priorities.