# Quiz 1 - Advanced JavaScript & React Concepts

---

## Question 1: URL Query String

**Question**: Trong một URL `https://api.example.com:3000/users?id=123#profile`, phần nào là query string?

**Options**:

- A) api.example.com
- B) :3000
- C) ?id=123 ✅
- D) #profile

**Answer**: `?id=123` ✅

**Explanation**: Query string bắt đầu bằng dấu `?` và chứa các parameters. Port là `:3000`, fragment là `#profile`, subdomain và domain là `api.example.com`.

---

## Question 2: Prototype Chain

**Question**: Output của đoạn code sau là gì?

```javascript
const parent = {
  company: "Google",
};

const child = Object.create(parent);
child.name = "React";

console.log(child.company);
```

**Options**:

- A) undefined
- B) Google ✅
- C) Ném ra lỗi ReferenceError
- D) null

**Answer**: `Google` ✅

**Explanation**: Đây là ví dụ về chuỗi prototype (prototype chain). `Object.create(parent)` tạo ra một đối tượng `child` mới với `[[Prototype]]` của nó trỏ đến `parent`. Khi truy cập `child.company`, JavaScript không tìm thấy thuộc tính này trên `child`, nó sẽ đi lên chuỗi prototype và tìm thấy nó trên `parent`.

---

## Question 3: JavaScript Event Loop

**Question**: Trong JavaScript Event Loop, khi nào một task được lấy từ task queue?

**Options**:

- A) Ngay khi task được thêm vào queue
- B) Khi call stack trống ✅
- C) Sau mỗi 16ms
- D) Khi có user interaction

**Answer**: Khi call stack trống ✅

**Explanation**: Event Loop chỉ lấy task từ task queue khi call stack hoàn toàn trống. Đây là cơ chế giúp JavaScript xử lý bất đồng bộ mặc dù chỉ có một thread.

---

## Question 4: Browser Reflow

**Question**: Reflow (hoặc Layout) trong trình duyệt là một quá trình tốn kém. Hành động nào sau đây chắc chắn sẽ gây ra Reflow?

**Options**:

- A) Thay đổi màu nền của một element
- B) Thay đổi thuộc tính transform: scale(1.1)
- C) Thay đổi chiều rộng (width) của một element ✅
- D) Thay đổi thuộc tính opacity

**Answer**: Thay đổi chiều rộng (width) của một element ✅

**Explanation**: Reflow (tính toán lại layout) xảy ra khi có sự thay đổi về hình học của các element (kích thước, vị trí), vì nó có thể ảnh hưởng đến vị trí của các element khác. Thay đổi width là một ví dụ điển hình. Thay đổi màu sắc (background-color) chỉ gây ra Repaint. Thay đổi transform và opacity thường được xử lý trên GPU và không gây ra Reflow hay Repaint, giúp hiệu năng tốt hơn.

---

## Question 5: Equality Operators

**Question**: Câu nào đúng về so sánh giữa `==` và `===`?

**Options**:

- A) `==` thường nhanh hơn vì có ép kiểu
- B) `===` thường nhanh hơn hoặc ngang vì không ép kiểu ✅
- C) `==` và `===` luôn cho kết quả như nhau
- D) `===` có thể ép kiểu nếu cần

**Answer**: `===` thường nhanh hơn hoặc ngang vì không ép kiểu ✅

**Explanation**: `===` (strict equality) thường nhanh hơn hoặc có hiệu năng tương đương vì không cần thực hiện ép kiểu. Khi so sánh bằng `==`, JavaScript phải kiểm tra bảng quy tắc ép kiểu phức tạp (Abstract Equality Comparison Algorithm) có thể dẫn đến nhiều bước chuyển đổi. Tuy nhiên, với các JavaScript engine hiện đại và JIT optimization, sự khác biệt có thể không đáng kể trong một số trường hợp cụ thể.

---

## Question 6: requestAnimationFrame

**Question**: Khi nào nên sử dụng `requestAnimationFrame()`?

**Options**:

- A) Khi cần thực hiện một tác vụ tính toán nặng ở background
- B) Khi cần gọi một API lấy dữ liệu từ server
- C) Khi cần thực hiện các cập nhật animation trên UI một cách mượt mà, đồng bộ với chu kỳ vẽ lại của trình duyệt ✅
- D) Khi cần trì hoãn một tác vụ cho đến khi CPU rảnh rỗi

**Answer**: Khi cần thực hiện các cập nhật animation trên UI một cách mượt mà, đồng bộ với chu kỳ vẽ lại của trình duyệt ✅

**Explanation**: `requestAnimationFrame(callback)` yêu cầu trình duyệt thực thi callback ngay trước lần vẽ (repaint) tiếp theo. Điều này giúp animation không bị giật, lag và tiết kiệm pin vì trình duyệt có thể tối ưu hóa, ví dụ như không chạy animation khi tab không hoạt động.

---

## Question 7: setTimeout Execution Order

**Question**: Đoạn code sau sẽ in ra kết quả theo thứ tự nào?

```javascript
console.log("Start");

setTimeout(() => {
  console.log("Timeout");
}, 0);

console.log("End");
```

**Options**:

- A) Start, Timeout, End
- B) Start, End, Timeout ✅
- C) Timeout, Start, End
- D) Thứ tự không thể đoán trước

**Answer**: Start, End, Timeout ✅

**Explanation**: `console.log('Start')` được thực thi. `setTimeout(..., 0)` không thực thi callback ngay lập tức, mà nó đưa callback vào Task Queue (thông qua Web API) để thực thi "ngay khi có thể". JS engine tiếp tục thực thi `console.log('End')`. Sau khi Call Stack trống, Event Loop lấy callback từ Task Queue ra và thực thi, in ra 'Timeout'.

---

## Question 8: Arrow Functions vs Regular Functions

**Question**: Đoạn code sau sẽ in ra gì?

```javascript
const obj = {
  value: 10,
  getValue: function () {
    return this.value;
  },
  getArrow: () => this.value,
};

console.log(obj.getValue()); // ?
console.log(obj.getArrow()); // ?
```

**Options**:

- A) 10, 10
- B) 10, undefined ✅
- C) undefined, 10
- D) undefined, undefined

**Answer**: 10, undefined ✅

**Explanation**: Trong một regular function như `getValue`, `this` được xác định bởi cách hàm được gọi. Khi gọi `obj.getValue()`, `this` trỏ đến `obj`, nên kết quả là 10. Ngược lại, arrow function như `getArrow` không có context `this` của riêng nó; nó kế thừa `this` từ scope bao quanh nó (lexical scope), trong trường hợp này là global scope. Ở global scope, `this.value` là `undefined`.

---

## Question 9: Object Keys

**Question**: Điều gì sẽ được in ra console khi thực thi đoạn code sau?

```javascript
const key1 = { id: 1 };
const key2 = { id: 2 };

const myObject = {};

myObject[key1] = "Value 1";
myObject[key2] = "Value 2";

console.log(myObject[key1]);
```

**Options**:

- A) Value 1
- B) Value 2 ✅
- C) undefined
- D) [object Object]

**Answer**: Value 2 ✅

**Explanation**: Khi một đối tượng được sử dụng làm key cho một Object khác, nó sẽ bị ép kiểu (coerced) thành một chuỗi thông qua phương thức `toString()`. Đối với các object thông thường, kết quả luôn là chuỗi `"[object Object]"`.

- `myObject[key1] = 'Value 1'` thực chất là `myObject["[object Object]"] = 'Value 1'`.
- `myObject[key2] = 'Value 2'` thực chất là `myObject["[object Object]"] = 'Value 2'`.

Dòng thứ hai đã ghi đè lên giá trị của dòng thứ nhất vì chúng cùng trỏ đến một key chuỗi. Đây là lý do tại sao `Map` lại vượt trội hơn `Object` khi cần dùng object làm key.

---

## Question 10: Event Loop Priority

**Question**: Kết quả log của đoạn code sau là gì?

```javascript
console.log(1);
setTimeout(() => console.log(2), 0);
Promise.resolve()
  .then(() => {
    console.log(3);
    queueMicrotask(() => console.log(4));
  })
  .then(() => console.log(5));
console.log(6);
```

**Options**:

- A) 1 6 3 5 4 2
- B) 1 6 3 4 5 2 ✅
- C) 1 3 6 4 5 2
- D) 1 6 5 3 4 2

**Answer**: 1 6 3 4 5 2 ✅

**Explanation**: Event Loop của JavaScript ưu tiên thực thi các task theo thứ tự sau:

1. **Synchronous Code (trong Call Stack)**: Tất cả các dòng code đồng bộ được thực thi trước tiên.

   - `console.log(1)` → in ra **1**
   - `setTimeout` đặt callback của nó vào **Macrotask Queue**.
   - `Promise.resolve().then()` đặt callback của nó vào **Microtask Queue**.
   - `console.log(6)` → in ra **6**

2. **Microtask Queue**: Sau khi call stack trống, toàn bộ Microtask Queue sẽ được xử lý cho đến khi hết.

   - Callback `.then()` đầu tiên chạy:
     - `console.log(3)` → in ra **3**
     - `queueMicrotask()` thêm một callback mới vào Microtask Queue
     - Khi callback này hoàn thành, promise resolve và callback `.then()` thứ hai được thêm vào Microtask Queue
   - Callback từ `queueMicrotask()` chạy tiếp theo (vì được thêm trước): `console.log(4)` → in ra **4**
   - Callback `.then()` thứ hai chạy: `console.log(5)` → in ra **5**

3. **Macrotask Queue**: Cuối cùng, khi Microtask Queue trống, Event Loop sẽ lấy một task từ Macrotask Queue.
   - Callback của `setTimeout` chạy: `console.log(2)` → in ra **2**

**Kết quả cuối cùng**: `1 6 3 4 5 2`

---

## Key Concepts Covered

1. **URL Structure**: Understanding query strings, fragments, and ports
2. **Prototype Chain**: How JavaScript inheritance works with `Object.create()`
3. **Event Loop**: Task queue processing and call stack management
4. **Browser Rendering**: Reflow vs Repaint and performance implications
5. **JavaScript Operators**: Performance differences between `==` and `===`
6. **Animation APIs**: When and why to use `requestAnimationFrame()`
7. **Asynchronous Execution**: Understanding `setTimeout()` behavior
8. **Function Context**: `this` binding in regular vs arrow functions
9. **Object Keys**: Type coercion and why `Map` is better for object keys
10. **Event Loop Priority**: Microtasks vs Macrotasks execution order

## Performance Tips

- Use `===` for predictable comparisons
- Avoid properties that trigger reflow (width, height, position)
- Use `requestAnimationFrame()` for smooth animations
- Understand that `setTimeout(fn, 0)` doesn't execute immediately
- Use `Map` when you need object keys
- Remember that microtasks have higher priority than macrotasks
