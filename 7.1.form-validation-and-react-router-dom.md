# 1. Form validation

## 1.1. Zod vs yup

- Define the shape of data and automatically validate it.

| Library     | `Type system`                    | `Typical usage`                       |
| :---------- | :------------------------------- | :------------------------------------ |
| **Yup**     | JS-first (runtime only)          | Validation rules, simple schemas      |
| **Zod**     | TS-first (static + runtime)      | Full type safety, modern TS apps      |

```js
// yup
const schema = yup.object({
    password: yup.string().required(),
    confirmPassword: yup.string().oneOf([yup.ref("password")], "Passwords must match"),
});
```

```js
// zod
const schema = z
    .object({
        password: z.string(),
        confirmPassword: z.string(),
    })
    .refine((data) => data.password === data.confirmPassword, {
        message: "Passwords must match",
        path: ["confirmPassword"],
    });
```

| Library                  | `Yup`                       | `Zod`                                 |
| :----------------------- | :-------------------------- | :------------------------------------ |
| **Code readability**     | Simpler for basic use       | More explicit for advanced cases      |
| **TypeScript support**   | Weak                        | Excellent                             |
| **Error message typing** | String-based                | Type-safe + structured                |
| **Schema composition**   | Limited chaining            | Very flexible chaining                |
| **Validation feedback**  | Traditional JS              | Functional, expressive                |

## 1.2. Zod with register in RHF

- RHF allows to define validation rules directly when registering a field.
- **Advantages**:
  - Simple syntax, no extra library needed.
  - Perfect for small forms or few validation rules.
  - Validation happens natively, so it's fast and lightweight.
- **Limitations**:
  - Hard to reuse validation logic between forms.
  - Complex conditional or cross-field validation (e.g., password confirm) gets messy.
    - Each field is validated in isolation - meaning:
      - The rule only applies to that single field.
      - It does not know about other fields' values.
      - Validation is triggered by events like *onBlur* or *onChange*.
    - Two related fields: *password* and *confirmPassword*
      - Inside the confirmPassword's own register rule, because it cannot see password's value.
  - No centralized schema to define the shape of data.
  - Harder to ensure full type safety (especially in large apps).

# 2. React router dom v7

- `route()`: defines normal route.
- `index()`: defines a default route rendered when the parent route matches exactly.
- All share the layout in `routes/layout.tsx`.
- Navigate to an id route:
  - `<Link to="users/1">Zod Form</Link>`.
  - `const params = useParams();`.
  - ID is inside params.
- `<Outlet>`: 
  - Is used in layout or parent route components to designate where the matched child route's component should render.
  - Enables nested UI/layouts: a parent route can render its own UI (nav/menu/sidebar) plus children.
  - Supports arbitrary nesting depths.
  - Helps keep layout code separated from page-component code.

```tsx
import { route, index } from "@react-router/dev/routes";

export default [
    route("/", "routes/layout.tsx", [
        index("routes/home.tsx"),
        route("about", "routes/about.tsx"),
        route("users", "routes/users.tsx", [
            route(":id", "routes/user-detail.tsx"),
        ]),
    ]),
] satisfies RouteConfig;
```

![react-router-dom-v7](/lessons/images/react-router-dom-v7.png)