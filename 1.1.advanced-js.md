# 1. URL (Universal Resources Locator)

http://example.com/product/electric/phone
Includes: scheme, domain, path, resource

When user enters a URL to browser:

1. Browser looks up IP in _DNS Cache_.
2. If DNS cache does not contain that URL, browser looks up IP using recursive DNS lookup by _DNS Resolver_ to _DNS Server_.
3. Browser establishes _TCP connection_ with the server.
4. Browser sends HTTP request to the server.
5. Server sends back HTTP response.
6. Browser renders HTTP content.
   **Note: DNS: Domain Name System**

# 2. Javascript

## 2.1 var, let, const

### var

- Hoisting:
  - Bring variable declaration to the top of its its scope (global if not in Strict mode).
  - Variable value is not hoisted.
- Function scope.

### let

- Block scope.
- No hoisting in the sense that it cannot be used before declaration.

### const

- Block scope.
- Cannot be re-assigned, cannot declare without initial value, but _the contents of object/array declared with const_ can still be modified.

## 2.2 type (common usages)

- Primitive types: string, number, boolean, null, undefined, symbol, bigint.
- Reference types: object, array, function.

## 2.3 == and ===

### == (Loose equality):

- Compares values after type coercion.
- Type coercion rules are complex and may lead to _unpredictable_ results.

### === (Strict Equality)

- Compares both value and data type.
- No type coercion.
- Easier to predict.

### Performance

- === does no type coercion -> predictable and safer.
- == a bit slower, applies type coercion with complex rules -> can cause bugs.

## 2.4 Objects & Prototypes

- JS has a **hidden link** ([[Prototype]]).
- When accessing a property that doesn't exist on an object, JS will look it up through the **prototype chain**.

## 2.5 Map

- is a _key-value_ collection, similar to Object, but with more _flexibility_ and _consistency_.
- Keys in a Map can be any type: primitive, object, function.
- Core methods: set, get, has, delete, clear, size.
- Pitfalls: cannot stringify, so should use: _JSON.stringify(Object.fromEntries(map))_.
- Object ({}) hash collision:
  - a collision happens when 2 different inputs result in the same hash.
  - collisions can overwrite existing data unintentionally.

#### Map vs Plain Object

| Category             | Object                                                   | Map                                                       |
| :------------------- | :------------------------------------------------------- | :-------------------------------------------------------- |
| **Key types**        | Only string or symbol (numbers get converted to strings) | Any value (primitive, object, function, NaN)              |
| **Order of keys**    | ES2015+: insertion order is mostly preserved             | Strict insertion order preserved                          |
| **Iteration**        | Requires helpers (Object.keys, Object.entries, for...in) | Built-in iterables (for...of, forEach, keys, values)      |
| **Performance**      | Optimized for small sets of static properties            | Optimized for frequent additions/removals/lookups         |
| **Prototype issues** | Has prototype chain                                      | Pure key-value store, no default keys                     |
| **Serialization**    | Works directly with JSON.stringify                       | Needs conversion (Object.fromEntries(map))                |
| **Best for**         | Structured/static configuration data                     | Dynamic collections, lookups, or keys that aren't strings |

## 2.6 Class (constructor function + new)

- Create a new object.
- ConstructorFunction.prototype
- **this** -> object

### Prototype Chain

Classes in JavaScript are syntactic sugar over constructor functions with prototype-based inheritance.

#### Class Definition Example

```javascript
class Animal {
  constructor(type) {
    this.type = type;
  }
}

class Dog extends Animal {
  constructor(name) {
    super("Dog");
    this.name = name;
  }
}

const rex = new Dog("Rex");
```

#### Prototype Relationships

```javascript
Dog.prototype.__proto__ = Animal.prototype;
Animal.prototype.__proto__ = Object.prototype;
```

#### Prototype Chain Flow

```
dog (instance: rex)
    __proto__ → Dog.prototype
                        __proto__ → Animal.prototype
                                            __proto__ → Object.prototype
                                                            __proto__ → null
```

#### Key Concepts

- **`__proto__`**: Hidden link between objects and their prototypes
- **Chain traversal**: When accessing a property, JavaScript walks up the prototype chain until found or null
- **Inheritance**: `extends` keyword sets up the prototype chain automatically
- **Instance properties**: Defined directly on the instance object
- **Prototype properties**: Shared across all instances of a class

## 2.7 requestAnimationFrame()

- A browser API for scheduling **visual updates** before the next repaint.
- Smooth animations (60fpx if possible).
- Efficient CPU/GPU usage (it pauses when tab is inactive).

```javascript
const id = requestAnimationFrame(callback);
cancelAnimationFrame(id);
```

- Queues **callback**.
- Callback will only **run right before** the next repaint (usually every ~16.7ms at 60Hz displays).
- Callback finishes, the browser decides: Layout / Paint / Composite -> display the new frame.
- Loop: wait until the next frame is ready.

```javascript
let start;
function step(timestamp) {
  if (!start) start = timestamp;
  const progress = timestamp - start;
  const box = document.querySelector(".box");
  box.style.transform = `translateX(${Math.min(progress / 10, 500)}px)`;
  if (progress < 2000) {
    requestAnimationFrame(step);
  }
}
requestAnimationFrame(step);
```

## 2.8 requestIdleCallback()

- Schedule a function to run when the main thread is idle.
- Runs only when the browser has **free time**.
- New actions keep the browser busy -> it delays execution.
- If no idle time is available within 2000ms -> the browser forces execution at the next chance, even if it's busy.

```javascript
const tasks = [fetchImage, fetchImage];
function doSomeHeavyTask(deadline) {
  if (deadline.timeRemaining > 0) {
    fetchImage();
    tasks.pop();
  }
  if (tasks.length > 0) {
    console.log("task");
    requestIdleCallback(doSomeHeavyTask);
  }
}
requestIdleCallback(doSomeHeavyTask, { timeout: 2000 });
```
