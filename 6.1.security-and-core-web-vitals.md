# 1. CORS (Cross-Origin Resource Sharing)

- A security mechanism implemented by browsers.
- Controls whether a web page from one origin (domain) is allowed to make requests to a different origin.

**Origin = scheme (protocol) + host (domain) + port**

frontend runs at http://localhost:3000
backend API is at https://api.example.com
-> a cross-origin request -> **CORS** applies.

- Simple requests
  - Use methods: GET, POST, HEAD.
  - Use "safe" headers only (e.g., Content-Type: application/x-www-form-urlencoded, text/plain, multipart/form-data).
- The browser automatically adds **Origin** url.
- If the server responds with **Access-Control-Allow-Origin**.

## 1.1. CORS in **postman** and **browser**??

- In browser:
  - Simple request:
    - Safe methods (GET, POST, HEAD) with limited headers.
    - Send request directly, check CORS headers afterward.
  - Pre-flighted request:
    - "Non-simple" methods (PUT, DELETE, PATCH) or custom headers.
    - Send **OPTIONS** first, check permission, then send real request.
  - Server responds to pre-flight:
    - Does Access-Control-Allow-Origin match the current Origin?
    - If credentials used -> is the header an exact match (not \*)?
    - If headers requested -> are they allowed?
  - If any of these fail, the browser: 
    - Silently discards the response body. 
    - Logs a CORS error.
    - The request still reach the server - it's the response that's blocked.

- In postman:
  - Is a **standalone HTTP client**, not a browser runtime.
    - It does not enforce CORS.
    - It sends HTTP requests directly to the server (like cURL).
  - Summary:
    - CORS = browser security mechanism -> Not part of HTTP or API spec.
    - Postman bypass CORS -> Sends direct requests without origin checks.
    - "Works in Postman but not in browser" -> Always a CORS header misconfiguration on server.
    - Fix = Server must explicitly allow frontend's origin -> Configure backend or proxy correctly.

# 2. XSS (Cross-Site Scripting)

- A type of client-side injection attack.
- A malicious actor can inject JS into a web page that runs in another user's browser.

## 2.1. How XSS works:

- Injection - Attacker finds a place where user input is reflected in the page.
  - e.g., a search field, comment box, or URL parameter.
- Execution - Browser renders the injected content as HTML/JS
- Impact - Malicious JS runs in the victim's context:
  - Steal cookies or JWT tokens.
  - Make fake requests (CSRF).
  - Modify DOM (deface site).
  - Redirect to phishing sites.
  - Keylog user input.

## 2.2. XSS attack types:

- Reflected XSS:
  - Injection happens through the URL or request.
  - Script is immediately reflected back in the response.
  - Common in query params, forms, and redirects.

Example:

```javascript
// https://example.com/search?query=laptop
// Result: <h1> Result for: laptop</h1>
// In BE: echo "Result for: " . $_GET["query"]

// If URL: https://example.com/search?query=<script>document.cookie</script>
// <h1>Result for: <script>document.cookie</script></h1>
// -> htmlspecialchars($_GET["query"])
```

- Stored XSS:
  - The most dangerous kind.
  - The malicious payload is stored on the server (DB, comment section, profile bio).
  - Every time a victim loads that page, the script executes.
  - How to prevent it:
    - Escape HTML characters: < -> &lt;
    - Sanitize input using security library (DOM purify).

- DOM-based XSS:
  - The vulnerability is in client-side JS, not the server.
  - The app uses untrusted data directly to build DOM elements or execute code.
  - Modern SPAs (React, Vue, Angular, etc.) when directly using innerHTML or dangerouslySetInnerHTML.

```javascript
const name = new URLSearchParams(location.search).get("name");
document.getElementById("greeting").innerHTML = "Hello " + name;
```

If URL = ...?name=<img src="..." onerror="alert('XSS')">
-> JavaScript executes when rendered.

## 2.3. Prevent XSS

- Escape / sanitize output:

```javascript
res.send(`<div>${escapeHtml(comment)}</div>`);
```

- Use safe DOM APIs:
  - Avoid innerHTML, document.write(), or eval() with untrusted data.
  - Instead: element.textContent = userInput;
- Enable CSP: _Content-Security-Policy: default-src 'self'; script-src 'self'_
- Set HttpOnly cookies -> JS cannot access cookies even if XSS occurs.
- Use framework-level sanitizers:
  - React: avoids XSS unless you use dangerouslySetInnerHTML.
  - Vue: automatically escapes content unless you use v-html.
  - Angular: uses built-in DomSanitizer.

# 3. CSP (Content Security Policy)

- Set up in server backend, can be set up for client side by HTML meta tag but less security.  
- Is a browser security feature designed to prevent:
  - Cross-Site Scripting (XSS).
  - Data injection attacks.
  - Clickjacking.
  - Loading malicious resources from untrusted domains.
  - Implemented via a special HTTP response haeader or <meta> tag
_Content-Security-Policy: default-src 'self'; img-src https://cdn.example.com; script-src 'self' https://apis.google.com; style-src 'self' 'unsafe-inline';_
  - Default: load everything only from the same origin ('self').
  - Images can come from *https://cdn.example.com*.
  - Scripts only from current site and apis.google.com.
  - Styles only from same site - but allows inline styles ('unsafe-inline').
    
Without CSP, a malicious attacker can inject scripts into the page (via XSS) and steal user tokens, cookies, or perform actions as the user.
-> If CSP is active and **disallows inline scripts** or untrusted sources, this script is **blocked by the browser** before it runs.

# 4. Web Vitals

- User experience.
- SEO ranking factor:
  - Google uses Core Web Vitals as a ranking signal in search results.
  - Better scores -> higher visibility -> more organic traffic.
- Conversion & Business Impact:
  - A 1s delay in LCP can reduce conversions by 7-10%
  - Poor INP can make the UI feel sluggish, discouraging engagement.
  - High CLS can cause accidental clicks - hurting UX and trust.

## 4.1. Core Web Vitals (2025)

- **LCP (Largest Contentful Paint)**
  - Loading performance: **<= 2.5s**.
  - Measures how quickly the largest visible element (e.g., image, video, or text block) renders in the viewport.
- **INP (Interaction to Next Paint)**
  - Interactivity responsiveness: **<= 200ms**.
  - Measures how quickly the page responds to user input (clicks, taps, keyboard actions).
- **CLS (Cumulative Layout Shift)**
  - Visual stability: **<= 0.1**
  - Measures unexpected layout shifts (e.g., content jumping as images load or ads appear).

## 4.2. Core Web Vitals: Causes and Fixes

This table outlines common issues leading to poor Core Web Vitals scores and their respective solutions.

| Category   | Poor LCP (Largest Contentful Paint)                                                                        | Poor INP (Interaction to Next Paint)                                                                                           | High CLS (Cumulative Layout Shift)                                                                                              |
| :--------- | :--------------------------------------------------------------------------------------------------------- | :----------------------------------------------------------------------------------------------------------------------------- | :------------------------------------------------------------------------------------------------------------------------------ |
| **Causes** | - Large or unoptimized images/videos<br>- Render-blocking scripts (JS/CSS)<br>- Unused third-party scripts | - Heavy JavaScript on main thread<br>- Unnecessary re-renders (React, Vue, etc.)<br>- Expensive computations in event handlers | - Images or ads with no fixed size<br>- Dynamically injected content above existing elements<br>- Web fonts causing text reflow |
| **Fix**    | - Use lazy-loading<br>- Optimize critical CSS<br>- Use a CDN & caching<br>- Preload critical assets        | - Use code-splitting & lazy loading<br>- Move heavy logic to Web Workers<br>- Use React.memo, useCallback, virtualization      | - Always specify width and height for media<br>- Reserve space for ads and embeds<br>- Use font-display: optional or swap       |

## 4.3. Render background images

- Background images are not prioritized by browsers as highly as <img /> tags.
- Often load after the HTML and CSS are parsed.
- Each background image is a separate HTTP request, so 10 requests = more latency.
  - CSS file includes all 10 background images as url() references:
    - Browser must fetch all of them before it can fully render those sections.
    - Increased Bandwidth and Memory Use.
-> Increase LCP, higher First Contentful Paint (FCP) and Total Blocking Time (TBT).
-> Users may stare at a black screen for longer.