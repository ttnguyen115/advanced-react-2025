# Performance Debugging

## 1. Profiler

- **Flamegraph**: Tree visualization showing render cost (thicker bars = slower renders).
- **Ranked**: Sorted list of most expensive components.
- **Timeline**:
  - **Sync**: **synchronous** and **high priority**
    - Typing in an input box, clicking a button
    - Must update the UI immediately to keep the app responsive to direct user actions
    - Blocking everything.
  - **Default**: **normal priority** updates (neither urgent or low)
    - Fetching data and setting state when it arrives.
    - React can schedule these updates more flexibly compared to Sync.
- **Transition**: updates wrapped in **startTransition**. They are considered **non-urgent**
  - Background rendering that can be interrupt if the user does something urgent.
- **TransitionHydration**: appears when React is hydrating a server-rendered tree (SSR) inside a transition.
  - Hydration scheduled as a transition (common in SSR + Suspense apps).

## 2. Performance

- **Network**: Shows when network requests start, are pending, and complete.
- **Frames**: Each frame = one screen refresh (~16.6ms at 60 FPS).
  - **Green bars** = frames rendered successfully.
  - **Red bars** = missed frames (jank / dropped frames).
- **Timings**:
  - FCP (First Contentful Paint) -> first time something is painted.
  - LCP (Largest Contentful Paint) -> biggest visible element painted.
  - DCL (DOMContentLoaded) -> HTML parsed & DOM tree built.
- **Interactions**:
  - User input traces (click, scroll, typing,...).
  - If typing causes long scripting tasks.
- **Main**:
  - Main thread (JavaScript + Style + Layout + Paint).
  - Show what code is executing:
    - Yellow bars = JavaScript execution.
    - Purple = Style recalculations.
    - Green = Layout / reflows.
    - Grey = Painting.

### Network handling:

- Check requests calling sequence or parallel?

#### Promise.all

- Returned promise fulfills when all of the input's promises fulfill.
- It rejects immediately when any of the input's promises rejects.

```js
try {
    const [res1, rest2] = await Promise.all([
        fetch("/res1"),
        fetch("/res2"),
    ]);
    const [data1, data2] = await Promise.all([
        res1.json(),
        res2.json(),
    ]);
} catch (err) { ... }
```

#### Promise.allSettled

- Waits for all promises to finish, giving you both successes and failures.

```js
Promise.allSettled([fetch("/res1"), fetch("/res2")])
  .then((results) => {
    return Promise.allSettled(
      results.map((r) => r.status === "fulfilled")
        ? r.value.json()
        : Promise.reject(r.reason)
    );
  })
  .then((parsedResults) => console.log("parsedResults ", parsedResults))
  .catch((err) => console.error("Caught error: ", err));
```

#### Promise.race

- Returns the first promise that settles (either fulfilled or rejected).
- Once one settles, the others are ignored.

```js
Promise.race([fetch("/res1"), fetch("/res2")])
  .then((res) => res.json())
  .then((data) => console.log("First response wins: ", data))
  .catch((err) => console.error("First error: ", err));
```

- Combine it with a timeout promise (or circuit breaker) to fail quickly if something is too slow.

```js
const timeout = (ms) =>
  new Promise((_, reject) =>
    setTimeout(() => reject(new Error("Timeout")), ms)
  );
Promise.race([fetch("/res1"), fetch("/res2"), timeout(2000)])
  .then((res) => res.json())
  .then((data) => console.log("Data: ", data))
  .catch((err) => console.error("Error: ", err));
```

#### Promise.any

- Returns the first fulfilled promise only.
- Ignores rejections unless all promises reject -> then it throws an AggregateError.

```js
Promise.race([fetch("/res1"), fetch("/res2")])
  .then((res) => res.json())
  .then((data) => console.log("Any data: ", data))
  .catch((err) => console.error("All errors: ", err.errors));
```

## 3. Tips

### Element render delay

- Gap between when the browser received the resource (image, text, video, etc.) and when it was actually painted on screen.
  -> Resouce was already available but the browser could not paint it until other blocking work finished.
- If **LCP > 2.5s** => **should improve**.
- Common causes of render delay:
  - **Main thread blocking** - long JavaScript tasks delaying rendering Style & layout calculations.
  - **Images/videos decoding** - even if fetched, large media needs decoding before render.

### Forced reflow

- Duplicated keys -> force browser to render all elements.
- Access element's layout styling right after changing its layout (e.g., getBoundingClientRect()) 
  -> force browser to render immediately to read its styling again without waiting for the next frame refresh every 16.6ms.

### When to need performance optimization

