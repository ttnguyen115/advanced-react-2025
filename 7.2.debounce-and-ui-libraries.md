# 1. Logical expressions

- **||** (Logical OR): a || b
  - Returns b if a is falsy, otherwise returns a.
  - Falsy values in JS are: **false**, **0**, **''** (empty string), **null**, **undefined**, **NaN**.
- **??** (Nullish Coalescing): a ?? b
  - Returns b only if a is null or undefined, otherwise returns a.

# 2. Debounce / Throttle

*Note: closure functions do not require to return a function, can return variables, objects. Closure functions are used to encapsulate the context of block code.*

## 2.1. Debounce

- A debounce function ensures that a function runs only after a certain amount of time has passed since the last call.
- Common use cases:
  - User typing in a search box -> wait until they stop typing to trigger API calls.
  - Window resize events -> trigger layout recalculation after resizing stops.
- Should use with `.apply(this, args)`, especially in class components:
  - Preserve the **this** context.
  - Pass along the arguments.

```js
// case 1: OK - because `this` already points to obj.
const obj = { 
    value: 42,
    logValue() { 
        console.log(this.value); 
    },
};

// case 2: NOT OK - because `this` will point to `input`.
input.addEventListener("input", debounce((e) => { 
    console.log(e.target.value); 
}, 300));

const debounced = debounce(obj.logValue, 500);
obj.logValue(); // 42
debounced(); // undefined (because `this` is lost)

// Good
function debounce(func, delay) {
    let timer;

    return (...args) => {
        clearTimeout(func);
        func = setTimeout(() => {
            callback(...args);
        }, delay);
    };
}

// Best
function debounce(func, delay) {
    let timer;

    return function(...args) {
        clearTimeout(timer);
        timer = setTimeout(() => {
            func.apply(this, args);
        }, delay);
    };
}
```

## 2.2. Throttle

- A throttle function ensures a function runs at most once every X milliseconds.
- How it works:
  - The first call runs immediately.
  - The it ignores new calls until delay milliseconds have passed.
  - After that time, the next call is allowed.

```js
function throttle(func, delay) {
    let lastTime = 0;

    return function(...args) {
        const now = Date.now();
        if (now - lastTime >= delay) {
            func.apply(this, args);
            lastTime = now;
        }
    };
}

window.addEventListener('scroll', throttle(() => {
    console.log('Scroll position: ', window.scrollY);
}, 1000));
```

# 3. UI Libraries

## 3.1. MUI (Material UI)

- **Strength**:
  - Mature, stable, and feature-rich ecosystem.
  - Huge component library: tables, grids, dialogs, charts, etc.
  - Excellent theming and dark mode support.
  - Large community, extensive docs, and 3rd-party templates.
- **Weaknesses**:
  - The Material Design look can feel restrictive - requires overrides for unique branding.
  - Slightly heavier bundle compared to lighter UI systems.
- **Best for**:
  - Enterprise apps, dashboards, admin systems.
  - Teams needing consistency and scalability.

## 3.2. Ant Design (AntD)

- **Strength**:
  - Very powerful for enterprise and admin dashboards.
  - Extensive component set (forms, tables, filters, pagination, etc.)
  - Strong TypeScript support, internationalization, RTL layout.
- **Weaknesses**:
  - Opinionated and recognizable design style - harder to fully customize.
  - Can be heavy for smaller projects.
- **Best for**:
  - Corporate web apps, CRMs, ERP dashboards.
  - Teams working on data-dense or form-intensive interfaces.

## 3.3. shadcn/ui (based on Radix UI + Tailwind CSS)

- **Strength**:
  - Modern, composable, and unstyled by default - perfect for building your own design system.
  - Tight integration with Tailwind CSS.
  - Great accessibility thanks to Radix primitives.
  - Trending fast in 2025; popular in the Next.js ecosystem.
- **Weaknesses**:
  - More setup and customization needed - not "plug and play".
  - Some instability and rough edges still being refined.
  - Requires solid Tailwind + React architecture skills.
- **Best for**:
  - Already use Tailwind CSS + Next.js.
  - Projects needing custom-branded, highly flexible UI.
  - Designers and developers comfortable with design systems.

### Radix UI

- A low-level, unstyled component library for React.
- Foundation layer - it gives all the logic, a11y, and behavior of UI components, but without any predefined styles.
  - The keyboard navigation logic (for menus, dropdowns, modals, sliders, etc.)
  - Focus trapping, a11y labels, ARIA attributes.
  - Composable and headless components.

# 4. Accessibility (a11y)

- Support people with disabilities can use the app effectively.
  - Rely on keyboard navigation instead of a mouse.
  - Use screen readers (assistive software that reads content aloud).
  - Have visual impairments (color blindness, low vision).
- Usages of using ARIA:
  - Using proper ARIA attributes (roles, aria-expanded, etc.).
  - Supporting keyboard focus (Tab, ArrowKeys, Enter, Esc, ect.).
  - Managing focus trapping in modals or dropdowns.
  - Ensuring sematic HTML structure (`button`, `input`, `nav`, etc.).
  - Handling visibility and state changes so assistive tools can react properly.

## Web Content Accessibility Guidelines (WCAG)