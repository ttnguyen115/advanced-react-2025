# Form handling

## 1. Controlled Component

- Is one where React state controls the value of the input:
  - Store the value in useState.
  - Update it via onChange.
  - The rendered value always equals React state.
- Usage example: catch every input live event to validate special characters.

```jsx
function ControlledExample() {
    const [name, setName] = useState('Test');
    return (
        <form>
            <input value={name} onChange={(e) => setName(e.target.value)}/>
            <p>Hello, {name}</p>
        </form>
    )
}
```

## 2. Uncontrolled Component

- Is a form input that stores its own state internally.
- React does not manage its value - the DOM does.
- The `<input />` keeps track of what typing, and can read the value only when needed (like on submit or with a ref).
- Very performant, minimal re-renders.

```jsx
function UncontrolledExample() {
    const inputRef = useRef(null);
    const handleSubmit = (e) => {
        e.preventDefault();
        console.log("Value ", inputRef.current?.value ?? "");
    }
    return (
        <form onSubmit={handleSubmit}>
            <input ref={inputRef} defaultValue="Test" />
            <button type="submit">Submit</button>
        </form>
    )
}
```

## 3. React-hook-form library

- A library that helps validate forms in React.
- RHF uses uncontrolled inputs (native form behavior) instead of controlled React state.
- Stills support controlled components, but uses uncontrolled inputs **by default**.
- Each input is registered once and updates form state via subscriptions, not React's re-render cycle.
- Bundle size = ~8KB gzipped (much smaller than Formik or Redux Form).

### 3.1. useForm

- Initializes the form state.
- Handles input registration & validation.
- Tracks field values, errors, touched state, and submission status.
- Returns helper methods for managing the form.

```jsx
import { useForm } from 'react-hook-form';

function LoginForm() {
    const {
        register,
        handleSubmit,
        formState: { errors },
    } = useForm({
        defaultValues: {
            email: "",
            password: "",
        }
    });

    const onSubmit = (data) => console.log(data);

    return (
        <form onSubmit={handleSubmit(onSubmit)}>
            <label htmlFor="email">Email</label>
            <input {...register("email", { required: true })} />
            {errors.email && <p>Email is required</p>}

            <label htmlFor="password">Password</label>
            <input {...register("password", { required: true })} />
            {errors.password && <p>Password is required</p>}
        </form>
    )
}
```

### 3.2. useWatch

- Subscribe to specific form values and reactively re-render component when those values change.
  - Does not rely on React Context updates - it's much faster for large forms.
- Without re-rendering the entire form or other fields.

```jsx
const value = useWatch({
    control,
    name?, // (optional) string | string[] | undefined
    defaultValue?, // (optional) any
})
```

- Works outside of the main form component (using *FormProvider*).
- With deep nested form, should handle form by `useFormProvider`.

=> **Tips**: design first, code later

![Form design first](/lessons/images/form-design.png)

```jsx
const methods = useForm({
    defaultValues: {...}
});

<FormProvider {...methods}>
    <Select1 />
    <Select2 />
</FormProvider>

// in Select1
import { useFormContext, useWatch } from 'react-hook-form';

function Select1() {
    const { control } = useFormContext();
    const value = useWatch({ control, name: "value" });
    return <div>Value: {value}</div>
}
```

### 3.3. control

- Core form state manager inside RHF.
- An object created by useForm() that holds:
  - The current values of all registered fields.
  - Validation rules.
  - Field subscriptions.
  - Methods to notify components when a field changes.
- All hooks and components connect to it.
- `control` is not just data - it also exposes internal Subjects and handlers that power reactivity.

```jsx
function App() {
    const { control, handleSubmit } = useForm();
    const onSubmit = (data) => console.log(data);
    return (
        <form onSubmit={handleSubmit(onSubmit)}>
            <input {...register("firstName")} />
            <input {...register("lastName")} />
            <LivePreview control={control} />
        </form>
    );
}

function LivePreview({ control }) {
    const [firstName, lastName] = useWatch({ control, name: ["firstName", "lastName"] });
    return <p>Hello, {firstName} {lastName}</p>
}
```

- Internally, RHF uses a publish-subscribe (pub/sub) pattern powered by observables:
  - Each field registered by `register()` emits updates into the control's subjects.
  - `useWatch()` subscribes to those subjects.
  - When the field's value changes -> control notifies all active subscribers.
  - React re-renders only the components using those subscriptions.
- `useWatch` without re-rendering whole form.
- `LivePreview` re-renders only when firstName or lastName changes. The rest of the form stays untouched.

=> **Tips**: when developing a live preview component, using `useWatch` and split into multiple small components to prevent re-renders for the big form, better DX for not managing the re-renders. With watching 2-way inputs -> use controlled components/useController.

## 4. useController

- Gives full control over a single input field's behavior.
- Developers will control component states -> controlled components.
- Do not use `useController()` (controlled component) with `register()` (uncontrolled component).
- Connects an input component to RHF's state management system.
  - Especially useful when cannot use `register()`

```jsx
function InputField({ name, control }) {
    // field: value, onChange, onBlur, ref, name,...
    // fieldState: invalid, isTouched, isDirty, error,...
    const { field, fieldState } = useController({
        name,
        control,
        rules: { required: "Email is required" },
        defaultValue: "",
    });

    return (
        <div>
            <label htmlFor={name}>{name}</label>
            <input {...field} placeholder={`Enter ${name}`} />
            {fieldState.error && <p>{fieldState.error.message}</p>}
        </div>
    )
}
```

### register() vs useController()

#### register

- **Uncontrolled component**
- RHF directly attaches refs and event listeners to the DOM inputs.

### useController

- **Controlled component**
- Input does not expose a ref or does not behave like a native input.

### Scenario

- Native `<input />`, `<select >` -> `register()`.
- 3rd-party controlled components (MUI, AntD, React-select,...) -> `useController()` or `<Controller />`.
- Need full fine-grained control of input behavior -> `useController()`.

## 5. useFormContext

- Allows to access the same form instance (control, register, watch,...) from any nested component, without passing props manually.
- Only works when the component tree is wrapped inside a `FormProvider`.

## 6. useFieldArray

- Manage dynamic fields inside a form.
- Keeps fields registered, validated, and synchronized.
- Returns: fields, append, prepend, insert, remove, swap, move (from, to), replace,...
- Subscribes to the **control** object (from useForm).
- Creates a **reactive connection** to a specific field path (e.g. "user").
- When calling append, remove, or modify the array:
  - The hook updates RHF's internal state.
  - Only the affected fields re-render, not the whole form (this is key to performance).
  - The returned fields array includes a unique id for React rendering stability.
- Applies `memo()` for separate input components to optimize the re-renders.

```jsx
function UserForm() {
    const { control, register, handleSubmit } = useForm({
        defaultValues: {
            users: [{ name: "Test" }],
        },
    });

    const { fields, append, remove } = useFieldArray({
        control,
        name: "users", // Must match the field path in defaultValues
    })

    return (
        <form onSubmit={handleSubmit(console.log)}>
            {fields.map((field, index) => (
                <div key={field.id}>
                    <input {...field} placeholder={`Enter ${name}`} />
                    <button type="button" onClick={() => remove(index)}>Remove</button>
                </div>
            ))}
            <button type="button" onClick={() => append({ name: "" })}>Add user</button>
            <button type="submit">Submit</button>
        </form>
    )
}
```
